// Copyright (C) 2024 wwhai
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

unsigned char modbus0103[] = {0x01, 0x03, 0x00, 0x01, 0x12, 0x34, 0x7d, 0x19};
#include <stdint.h>
// uint8_t myData[5] = {0x01, 0x03, 0x00, 0x01, 0x00};
// uint16_t crcValue = calculateModbusCRC(myData, 5);
uint16_t calculateModbusCRC(uint8_t *data, uint16_t length)
{
    uint16_t crc = 0xFFFF;
    for (uint16_t pos = 0; pos < length; pos++)
    {
        crc ^= (uint16_t)data[pos]; // XOR byte into least sig. byte of crc

        for (uint8_t i = 8; i != 0; i--)
        { // Loop over each bit
            if ((crc & 0x0001) != 0)
            {              // If the LSB is set
                crc >>= 1; // Shift right and XOR 0xA001
                crc ^= 0xA001;
            }
            else
            {              // Else LSB is not set
                crc >>= 1; // Just shift right
            }
        }
    }
    return crc;
}
// 读取寄存器的报文 (功能码03 - 读保持寄存器)
unsigned char modbus_read1[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x0B};
unsigned char modbus_read2[] = {0x02, 0x03, 0x00, 0x10, 0x00, 0x04, 0x85, 0xF7};
unsigned char modbus_read3[] = {0x03, 0x03, 0x00, 0x20, 0x00, 0x01, 0x44, 0x1C};
unsigned char modbus_read4[] = {0x04, 0x03, 0x01, 0x00, 0x00, 0x06, 0xD5, 0x88};
unsigned char modbus_read5[] = {0x05, 0x03, 0x0A, 0x00, 0x00, 0x0A, 0x54, 0x9D};

// 写单个寄存器的报文 (功能码06 - 写单个保持寄存器)
unsigned char modbus_write1[] = {0x01, 0x06, 0x00, 0x01, 0x04, 0xD2, 0x09, 0xCB};
unsigned char modbus_write2[] = {0x02, 0x06, 0x00, 0x11, 0x16, 0x2E, 0xA9, 0xA7};
unsigned char modbus_write3[] = {0x03, 0x06, 0x00, 0x21, 0x9A, 0xBC, 0x19, 0xDF};
unsigned char modbus_write4[] = {0x04, 0x06, 0x01, 0x01, 0xDE, 0xFF, 0x1A, 0x32};
unsigned char modbus_write5[] = {0x05, 0x06, 0x0A, 0x01, 0x43, 0x21, 0x7B, 0xBD};

// 读取线圈的报文 (功能码01 - 读线圈状态)
unsigned char modbus_read_coil1[] = {0x01, 0x01, 0x00, 0x01, 0x00, 0x08, 0x3D, 0xC9};
unsigned char modbus_read_coil2[] = {0x02, 0x01, 0x00, 0x11, 0x00, 0x10, 0x3C, 0x0D};
unsigned char modbus_read_coil3[] = {0x03, 0x01, 0x00, 0x21, 0x00, 0x0C, 0xBC, 0x79};
unsigned char modbus_read_coil4[] = {0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 0x7D, 0xB4};
unsigned char modbus_read_coil5[] = {0x05, 0x01, 0x0A, 0x01, 0x00, 0x14, 0xBD, 0x98};

// 写单个线圈的报文 (功能码05 - 写单个线圈)
unsigned char modbus_write_coil1[] = {0x01, 0x05, 0x00, 0x01, 0xFF, 0x00, 0xDD, 0xFA};
unsigned char modbus_write_coil2[] = {0x02, 0x05, 0x00, 0x11, 0x00, 0x00, 0x8C, 0x17};
unsigned char modbus_write_coil3[] = {0x03, 0x05, 0x00, 0x21, 0xFF, 0x00, 0x0C, 0x63};
unsigned char modbus_write_coil4[] = {0x04, 0x05, 0x01, 0x01, 0x00, 0x00, 0x4C, 0x1E};
unsigned char modbus_write_coil5[] = {0x05, 0x05, 0x0A, 0x01, 0xFF, 0x00, 0xCC, 0x32};
